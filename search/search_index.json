{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"fHDHR \u00b6 The Boring Disclaimers \u00b6 Note: these are At the top of the docs for a reason fHDHR is a Python service to take various sources of video and make them accessible to client software including, but not limited to*: Plex Emby Jellyfin Channels fHDHR is not directly affiliated with the above client software, and you will receive NO support for this script via their forums. fHDHR was designed to connect to clients by emulating a piece of hardware called the HDHomeRun from SiliconDust . fHDHR is in NO way affiliated with SiliconDust, and is NOT a HDHomeRun device. fHDHR simply uses the API structure used by the authentic HDHomeRun to connect to client DVR solutions (this functionality has since been moved to a plugin). fHDHR core supports m3u, but with plugins can emulate an HDHomeRun, or a Plex Media Grabber. Other interfaces to clients can easily be developed as plugins as well. History \u00b6 I got the Hauppage QuadHD, and the Mohu Sail as a pandemic-project. All was fine working within Plex, but I also have Emby setup as a backup to Plex when auth is broken. I thought to myself, \"Self, I should look on github for a way to share my tv tuner between the two\". That's when I tried both npvrProxy with NextPVR as well as tvhProxy with TVHeadend. I had to tinker with both to get them working, but I started testing which one I liked more. Around this same time, I stumbled upon locast2plex by tgorgdotcom . I wanted to contribute to that project to get it to a point that I could fork it to work for other video stream sources. The locast2plex code development wasn't going quite fast enough for the feature-creep in my head. I then proceded to create the initial iteration of fHDHR which I originally called \"FakeHDHR\". I've rewritten the core functionality a few times before landing on the current code structure, which feels 'right'. I've worked really hard to create a structure that simplifies new variants of the core code to work with different 'origin' streams. Combining these works really well with xTeVe . One of the variants goes as far as scraping a table from a PDF file for creating a channel guide! I can easily create more variants of the project to do other video sources. Paid ones, I could potentially accept donations for, as I don't want to pay to develop for multiple platforms.","title":"Home"},{"location":"#fhdhr","text":"","title":"fHDHR"},{"location":"#the-boring-disclaimers","text":"Note: these are At the top of the docs for a reason fHDHR is a Python service to take various sources of video and make them accessible to client software including, but not limited to*: Plex Emby Jellyfin Channels fHDHR is not directly affiliated with the above client software, and you will receive NO support for this script via their forums. fHDHR was designed to connect to clients by emulating a piece of hardware called the HDHomeRun from SiliconDust . fHDHR is in NO way affiliated with SiliconDust, and is NOT a HDHomeRun device. fHDHR simply uses the API structure used by the authentic HDHomeRun to connect to client DVR solutions (this functionality has since been moved to a plugin). fHDHR core supports m3u, but with plugins can emulate an HDHomeRun, or a Plex Media Grabber. Other interfaces to clients can easily be developed as plugins as well.","title":"The Boring Disclaimers"},{"location":"#history","text":"I got the Hauppage QuadHD, and the Mohu Sail as a pandemic-project. All was fine working within Plex, but I also have Emby setup as a backup to Plex when auth is broken. I thought to myself, \"Self, I should look on github for a way to share my tv tuner between the two\". That's when I tried both npvrProxy with NextPVR as well as tvhProxy with TVHeadend. I had to tinker with both to get them working, but I started testing which one I liked more. Around this same time, I stumbled upon locast2plex by tgorgdotcom . I wanted to contribute to that project to get it to a point that I could fork it to work for other video stream sources. The locast2plex code development wasn't going quite fast enough for the feature-creep in my head. I then proceded to create the initial iteration of fHDHR which I originally called \"FakeHDHR\". I've rewritten the core functionality a few times before landing on the current code structure, which feels 'right'. I've worked really hard to create a structure that simplifies new variants of the core code to work with different 'origin' streams. Combining these works really well with xTeVe . One of the variants goes as far as scraping a table from a PDF file for creating a channel guide! I can easily create more variants of the project to do other video sources. Paid ones, I could potentially accept donations for, as I don't want to pay to develop for multiple platforms.","title":"History"},{"location":"adv_config/","text":"Advanced Config \u00b6 Here, we'll break down all of the configuration options per section. Main \u00b6 Here's the main section. uuid will be created automatically, you need not worry about this. cache_dir is handy for keeping cached files out of the script directory. This is helpful for reinstalls as well as development. [main] # uuid = # cache_dir = Streaming \u00b6 method can be set to ffmpeg , vlc or direct . bytes_per_read determines how many bytes of the stream to read before sending the data to your client. Increasing this value may cause longer load times, and lowering it may effect stuttering . origin_quality can be set to high,medium,low for most variants. Variants that make use of m3u8 will Autoselect High for the direct method if not set. ffmpeg/vlc will determine the best stream on their own. Some Variants can allow alternative values. transcode_quality works with ffmpeg/vlc to use fHDHR for handling quality instead of the origin. Valid settings include: heavy,mobile,internet720,internet480,internet360,internet240 [streaming] # method = direct # bytes_per_read = 1152000 # origin_quality = None # transcode_quality = None fhdhr \u00b6 The fhdhr contains all the configuration options for interfacing between this script and your media platform. address and port are what we will allow the script to listen on. 0.0.0.0 is the default, and will respond to all. discovery_address may be helpful for making SSDP work properly. If address is not 0.0.0.0 , we will use that. If this is not set to a real IP, we won't run SSDP. SSDP is only really helpful for discovering in Plex/Emby. It's a wasted resource since you can manually add the ip : port of the script to Plex. tuner_count is a limit of devices able to stream from the script. The default is 4. friendlyname is to set the name that Plex sees the script as. reporting_* are settings that show how the script projects itself as a hardware device. device_auth and require_auth are for an unimplemented Authentication feature. chanscan_on_start Scans Origin for new channels at startup. [fhdhr] # address = 0.0.0.0 # discovery_address = 0.0.0.0 # port = 5004 # tuner_count = 4 # friendlyname = fHDHR # reporting_firmware_name = fHDHR # reporting_manufacturer = BoronDust # reporting_model = fHDHR # reporting_firmware_ver = 20201001 # reporting_tuner_type = Antenna # device_auth = fHDHR # require_auth = False # chanscan_on_start = True EPG \u00b6 images can be set to proxy or pass . If you choose proxy , images will be reverse proxied through fHDHR. method which method(s) to use for xmltv generation. update_frequency determines how often we check for new scheduling information. In Seconds. reverse_days allows Blocks of EPG data to be created prior to the start of the EPG Source data. forward_days allows Blocks of EPG data to be created after the end of the EPG Source data. block_size in seconds, sets the default block size for data before, after and missing timeslots. xmltv_offset allows the final xmltv file to have an offset for users with timezone issues. [epg] # images = pass # method = None # update_frequency = 43200 # reverse_days = 1 # forward_days = 7 # block_size = 1800 # xmltv_offset = +0000 ffmpeg \u00b6 The ffmpeg section includes: path . This is useful if ffmpeg is not in your systems PATH, or you want to manually specify. [ffmpeg] # path = ffmpeg vlc \u00b6 The vlc section includes: path . This is useful if vlc is not in your systems PATH, or you want to manually specify. [vlc] # path = cvlc Logging \u00b6 level determines the amount of logging you wish to see in the console, as well as to the logfile (stored in your cache directory). [logging] # level = WARNING Database \u00b6 experiment with these settings at your own risk. We use sqlalchemy to provide database options, but we default to sqlite. Note: this section needs improvement. [database] # type = sqlite # driver = None user = None pass = None host = None port = None name = None RMG \u00b6 # enabled = True SSDP \u00b6 # enabled = True # max_age = 1800 # proto = ipv6 # iface = None # multicast_address = None","title":"Advanced Config"},{"location":"adv_config/#advanced-config","text":"Here, we'll break down all of the configuration options per section.","title":"Advanced Config"},{"location":"adv_config/#main","text":"Here's the main section. uuid will be created automatically, you need not worry about this. cache_dir is handy for keeping cached files out of the script directory. This is helpful for reinstalls as well as development. [main] # uuid = # cache_dir =","title":"Main"},{"location":"adv_config/#streaming","text":"method can be set to ffmpeg , vlc or direct . bytes_per_read determines how many bytes of the stream to read before sending the data to your client. Increasing this value may cause longer load times, and lowering it may effect stuttering . origin_quality can be set to high,medium,low for most variants. Variants that make use of m3u8 will Autoselect High for the direct method if not set. ffmpeg/vlc will determine the best stream on their own. Some Variants can allow alternative values. transcode_quality works with ffmpeg/vlc to use fHDHR for handling quality instead of the origin. Valid settings include: heavy,mobile,internet720,internet480,internet360,internet240 [streaming] # method = direct # bytes_per_read = 1152000 # origin_quality = None # transcode_quality = None","title":"Streaming"},{"location":"adv_config/#fhdhr","text":"The fhdhr contains all the configuration options for interfacing between this script and your media platform. address and port are what we will allow the script to listen on. 0.0.0.0 is the default, and will respond to all. discovery_address may be helpful for making SSDP work properly. If address is not 0.0.0.0 , we will use that. If this is not set to a real IP, we won't run SSDP. SSDP is only really helpful for discovering in Plex/Emby. It's a wasted resource since you can manually add the ip : port of the script to Plex. tuner_count is a limit of devices able to stream from the script. The default is 4. friendlyname is to set the name that Plex sees the script as. reporting_* are settings that show how the script projects itself as a hardware device. device_auth and require_auth are for an unimplemented Authentication feature. chanscan_on_start Scans Origin for new channels at startup. [fhdhr] # address = 0.0.0.0 # discovery_address = 0.0.0.0 # port = 5004 # tuner_count = 4 # friendlyname = fHDHR # reporting_firmware_name = fHDHR # reporting_manufacturer = BoronDust # reporting_model = fHDHR # reporting_firmware_ver = 20201001 # reporting_tuner_type = Antenna # device_auth = fHDHR # require_auth = False # chanscan_on_start = True","title":"fhdhr"},{"location":"adv_config/#epg","text":"images can be set to proxy or pass . If you choose proxy , images will be reverse proxied through fHDHR. method which method(s) to use for xmltv generation. update_frequency determines how often we check for new scheduling information. In Seconds. reverse_days allows Blocks of EPG data to be created prior to the start of the EPG Source data. forward_days allows Blocks of EPG data to be created after the end of the EPG Source data. block_size in seconds, sets the default block size for data before, after and missing timeslots. xmltv_offset allows the final xmltv file to have an offset for users with timezone issues. [epg] # images = pass # method = None # update_frequency = 43200 # reverse_days = 1 # forward_days = 7 # block_size = 1800 # xmltv_offset = +0000","title":"EPG"},{"location":"adv_config/#ffmpeg","text":"The ffmpeg section includes: path . This is useful if ffmpeg is not in your systems PATH, or you want to manually specify. [ffmpeg] # path = ffmpeg","title":"ffmpeg"},{"location":"adv_config/#vlc","text":"The vlc section includes: path . This is useful if vlc is not in your systems PATH, or you want to manually specify. [vlc] # path = cvlc","title":"vlc"},{"location":"adv_config/#logging","text":"level determines the amount of logging you wish to see in the console, as well as to the logfile (stored in your cache directory). [logging] # level = WARNING","title":"Logging"},{"location":"adv_config/#database","text":"experiment with these settings at your own risk. We use sqlalchemy to provide database options, but we default to sqlite. Note: this section needs improvement. [database] # type = sqlite # driver = None user = None pass = None host = None port = None name = None","title":"Database"},{"location":"adv_config/#rmg","text":"# enabled = True","title":"RMG"},{"location":"adv_config/#ssdp","text":"# enabled = True # max_age = 1800 # proto = ipv6 # iface = None # multicast_address = None","title":"SSDP"},{"location":"config/","text":"Config \u00b6 The example config file contains all of the things that the typical user may need to fill out. The 3 basic items in the fhdhr section are the only ones that you should be concerned with setting. The WebUI has a settings page with access to the same settings. Please see the Advanced Configuration page for more settings. fHDHR \u00b6 Under fhdhr , you'll find 2 addresses listed. 0.0.0.0 works great for a listen address, however, it seems that SSDP works best if the discovery address is set to the IP to say that there is a service at. [fhdhr] # address = 0.0.0.0 # port = 5004 # discovery_address = 0.0.0.0","title":"Basic Config"},{"location":"config/#config","text":"The example config file contains all of the things that the typical user may need to fill out. The 3 basic items in the fhdhr section are the only ones that you should be concerned with setting. The WebUI has a settings page with access to the same settings. Please see the Advanced Configuration page for more settings.","title":"Config"},{"location":"config/#fhdhr","text":"Under fhdhr , you'll find 2 addresses listed. 0.0.0.0 works great for a listen address, however, it seems that SSDP works best if the discovery address is set to the IP to say that there is a service at. [fhdhr] # address = 0.0.0.0 # port = 5004 # discovery_address = 0.0.0.0","title":"fHDHR"},{"location":"installation_docker/","text":"Docker \u00b6 Pre-Run Requirements \u00b6 fHDHR does not create a config file itself, nor does it come with a default one in place. If enough demand for one is there we may build a check to auto-create it, but at present there is no plan to do so. As such, before you run either of the below methods (only one, not both), be sure to create the folder and config file that you'll be passing in to the fHDHR container. Creating Required Paths \u00b6 The following commands will create the required directories and files. Be sure change the directory path to match your desired location. mkdir -p /path/to/config mkdir -p /path/to/plugins touch /path/to/config/config.ini If you wish to keep a persistent cache, you can also create a directory for the cache. This allows channels that were disabled or favorited to be persistent after restarting the container. Docker CLI \u00b6 docker run -d --name = fhdhr -v /path/to/config:/app/config -v /path/to/plugins:/app/plugins --network host --restart = unless-stopped fhdhr/fhdhr:latest If you wish to include the persistent cache, simply include -v /path/to/cache:/app/data/cache in the above command. Docker Compose \u00b6 version: \"2.1\" services: fhdhr: image: \"fhdhr/fhdhr:latest\" container_name: fhdhr environment: - PUID=1000 - PGID=1000 - TZ=Pacific/Auckland volumes: - /path/to/config:/app/config - /path/to/plugins:/app/plugins - /path/to/cache:/app/data/cache # Optional network_mode: host restart: unless-stopped","title":"Docker"},{"location":"installation_docker/#docker","text":"","title":"Docker"},{"location":"installation_docker/#pre-run-requirements","text":"fHDHR does not create a config file itself, nor does it come with a default one in place. If enough demand for one is there we may build a check to auto-create it, but at present there is no plan to do so. As such, before you run either of the below methods (only one, not both), be sure to create the folder and config file that you'll be passing in to the fHDHR container.","title":"Pre-Run Requirements"},{"location":"installation_docker/#creating-required-paths","text":"The following commands will create the required directories and files. Be sure change the directory path to match your desired location. mkdir -p /path/to/config mkdir -p /path/to/plugins touch /path/to/config/config.ini If you wish to keep a persistent cache, you can also create a directory for the cache. This allows channels that were disabled or favorited to be persistent after restarting the container.","title":"Creating Required Paths"},{"location":"installation_docker/#docker-cli","text":"docker run -d --name = fhdhr -v /path/to/config:/app/config -v /path/to/plugins:/app/plugins --network host --restart = unless-stopped fhdhr/fhdhr:latest If you wish to include the persistent cache, simply include -v /path/to/cache:/app/data/cache in the above command.","title":"Docker CLI"},{"location":"installation_docker/#docker-compose","text":"version: \"2.1\" services: fhdhr: image: \"fhdhr/fhdhr:latest\" container_name: fhdhr environment: - PUID=1000 - PGID=1000 - TZ=Pacific/Auckland volumes: - /path/to/config:/app/config - /path/to/plugins:/app/plugins - /path/to/cache:/app/data/cache # Optional network_mode: host restart: unless-stopped","title":"Docker Compose"},{"location":"plugins/","text":"Plugins \u00b6 There are several plugin types for fHDHR. See below for details regarding what each type is. Note : if you wish to use fHDHR with Plex you will need fHDHR_plugin_interface_hdhr , as it allows fHDHR to masquerade as an HDHomeRun device (so Plex can understand it). Origins \u00b6 Look here for plugins that start with \"fHDHR_plugin_origin_\". An Origin plugin is where we are streaming video from. It provides fHDHR with a channel listing, and how to connect to a service to stream from. Some Origin plugins will provide EPG data. Those that don't will have blocks of empty timeslot data created. Some Origin Plugins will also provide an added webpage to the webUI. Without an Origin plugin installed, fHDHR really cannot do much of anything. Interface Plugins \u00b6 Look here for plugins that start with \"fHDHR_plugin_interface_\". Interface plugins provide additionally access to fHDHR. By default, fHDHR provides basic channel with an accessible API for channel tuning, EPG, and m3u. A plugin of most interest to the average user will be the fHDHR_plugin_interface_hdhr plugin. This plugin provides Plex access to fHDHR as if it was a HDHomeRun device, and as a result is mandatory if you want to connect Plex to fHDHR . Stream Plugins \u00b6 Look Here for plugins that start with \"fHDHR_plugin_stream_\". These plugins provide alternative methods for streaming. At it's core fHDHR was designed to NOT rely on ffmpeg/vlc to run. These plugins can allow transcoding at the fHDHR level, whereas fHDHR core cannot. EPG Plugins \u00b6 Look here for plugins that start with \"fHDHR_plugin_epg_\". These plugins provide alternative sources of EPG information. This can be handy for origin plugins that don't provide good/any EPG.","title":"Plugins"},{"location":"plugins/#plugins","text":"There are several plugin types for fHDHR. See below for details regarding what each type is. Note : if you wish to use fHDHR with Plex you will need fHDHR_plugin_interface_hdhr , as it allows fHDHR to masquerade as an HDHomeRun device (so Plex can understand it).","title":"Plugins"},{"location":"plugins/#origins","text":"Look here for plugins that start with \"fHDHR_plugin_origin_\". An Origin plugin is where we are streaming video from. It provides fHDHR with a channel listing, and how to connect to a service to stream from. Some Origin plugins will provide EPG data. Those that don't will have blocks of empty timeslot data created. Some Origin Plugins will also provide an added webpage to the webUI. Without an Origin plugin installed, fHDHR really cannot do much of anything.","title":"Origins"},{"location":"plugins/#interface-plugins","text":"Look here for plugins that start with \"fHDHR_plugin_interface_\". Interface plugins provide additionally access to fHDHR. By default, fHDHR provides basic channel with an accessible API for channel tuning, EPG, and m3u. A plugin of most interest to the average user will be the fHDHR_plugin_interface_hdhr plugin. This plugin provides Plex access to fHDHR as if it was a HDHomeRun device, and as a result is mandatory if you want to connect Plex to fHDHR .","title":"Interface Plugins"},{"location":"plugins/#stream-plugins","text":"Look Here for plugins that start with \"fHDHR_plugin_stream_\". These plugins provide alternative methods for streaming. At it's core fHDHR was designed to NOT rely on ffmpeg/vlc to run. These plugins can allow transcoding at the fHDHR level, whereas fHDHR core cannot.","title":"Stream Plugins"},{"location":"plugins/#epg-plugins","text":"Look here for plugins that start with \"fHDHR_plugin_epg_\". These plugins provide alternative sources of EPG information. This can be handy for origin plugins that don't provide good/any EPG.","title":"EPG Plugins"},{"location":"related-projects/","text":"Related Projects \u00b6 While the fHDHR reops share very little code from the below projects, they were a source of inspiration: tvhProxy by jkaberg locast2plex by tgorgdotcom Aside from the above, these other projects are worth a look as well: npvrProxy xTeVe telly dizquetv","title":"Related Projects"},{"location":"related-projects/#related-projects","text":"While the fHDHR reops share very little code from the below projects, they were a source of inspiration: tvhProxy by jkaberg locast2plex by tgorgdotcom Aside from the above, these other projects are worth a look as well: npvrProxy xTeVe telly dizquetv","title":"Related Projects"},{"location":"submitting_docs/","text":"fHDHR.Docs \u00b6 This is the fHDHR Docs site. It's not always up-to-date, because our primary developer is a bit of an overachiever. If you'd like to get involved with the project, reach out in #fhdhr over on Freenode (and yes, we know IRC is old). Setting up a dev environment \u00b6 The easiest method to install mkdocs is via python - it's consistent across different OS environments. Install Python for your OS, ensuring that it gets added to PATH. Once you have Python installed, you'll need to clone the repository and install the python packages used by this site (like mkdocs itself). To do this, clone the repo, and from the relevant terminal/shell/prompt, change directory to the repo folder and run pip install -r requirements.txt to ensure you have all the relevant packages for use. Editing the site \u00b6 To edit the site content, edit the markdown files under \"docs\". To edit the site layout, edit the mkdocs.yml file (held in the root directory). Note that the new documentation repository is not directly publicly editable - for a few reasons, including (but not limited to): Markup (as used in mkdocs.yml ) is an indent-sensitive language. Markdown (what all the pages themselves are written with) has defined standards. We'd like to be able to validate content before it gets put into official documentation (the old wiki had a lot of inaccurate community-submitted content). As such, all edit requests will need to go through approval by submitting a pull request . Suggested editor \u00b6 VS Code is a good option to use for editing this content, as it has extensions for markup and markdown syntax highlighting (as well as preview functions). Included in this repository is a workspace config for vscode with some defined spelling, linting, and error-checking methods, as well as a group of recommended VS Code extensions for use. Atom is another good option. Using mkdocs \u00b6 The site is being built using mkdocs , which converts standard markdown to static html. mkdocs itself can be told to 'serve' the folder by opening the folder containing mkdocs.yml in your relevant console/terminal and running mkdocs serve . This will let you live preview the site in your browser, with changes being updated any time you save an edit to a file. mkdocs references \u00b6 Source reference: mkdocs wiki Material theme Example Configs https://github.com/GhostWriters/DockSTARTer/blob/master/mkdocs.yml https://github.com/selfhosters/selfhosters.net/blob/master/mkdocs.yml https://github.com/pi-hole/docs/blob/master/mkdocs.yml https://github.com/TRaSH-/Guides/blob/master/mkdocs.yml ) https://github.com/IronicBadger/pms-wiki/blob/main/mkdocs.yml )","title":"Submitting to the docs"},{"location":"submitting_docs/#fhdhrdocs","text":"This is the fHDHR Docs site. It's not always up-to-date, because our primary developer is a bit of an overachiever. If you'd like to get involved with the project, reach out in #fhdhr over on Freenode (and yes, we know IRC is old).","title":"fHDHR.Docs"},{"location":"submitting_docs/#setting-up-a-dev-environment","text":"The easiest method to install mkdocs is via python - it's consistent across different OS environments. Install Python for your OS, ensuring that it gets added to PATH. Once you have Python installed, you'll need to clone the repository and install the python packages used by this site (like mkdocs itself). To do this, clone the repo, and from the relevant terminal/shell/prompt, change directory to the repo folder and run pip install -r requirements.txt to ensure you have all the relevant packages for use.","title":"Setting up a dev environment"},{"location":"submitting_docs/#editing-the-site","text":"To edit the site content, edit the markdown files under \"docs\". To edit the site layout, edit the mkdocs.yml file (held in the root directory). Note that the new documentation repository is not directly publicly editable - for a few reasons, including (but not limited to): Markup (as used in mkdocs.yml ) is an indent-sensitive language. Markdown (what all the pages themselves are written with) has defined standards. We'd like to be able to validate content before it gets put into official documentation (the old wiki had a lot of inaccurate community-submitted content). As such, all edit requests will need to go through approval by submitting a pull request .","title":"Editing the site"},{"location":"submitting_docs/#suggested-editor","text":"VS Code is a good option to use for editing this content, as it has extensions for markup and markdown syntax highlighting (as well as preview functions). Included in this repository is a workspace config for vscode with some defined spelling, linting, and error-checking methods, as well as a group of recommended VS Code extensions for use. Atom is another good option.","title":"Suggested editor"},{"location":"submitting_docs/#using-mkdocs","text":"The site is being built using mkdocs , which converts standard markdown to static html. mkdocs itself can be told to 'serve' the folder by opening the folder containing mkdocs.yml in your relevant console/terminal and running mkdocs serve . This will let you live preview the site in your browser, with changes being updated any time you save an edit to a file.","title":"Using mkdocs"},{"location":"submitting_docs/#mkdocs-references","text":"Source reference: mkdocs wiki Material theme Example Configs https://github.com/GhostWriters/DockSTARTer/blob/master/mkdocs.yml https://github.com/selfhosters/selfhosters.net/blob/master/mkdocs.yml https://github.com/pi-hole/docs/blob/master/mkdocs.yml https://github.com/TRaSH-/Guides/blob/master/mkdocs.yml ) https://github.com/IronicBadger/pms-wiki/blob/main/mkdocs.yml )","title":"mkdocs references"},{"location":"usage/","text":"Usage \u00b6 Author Notes \u00b6 All Testing is currently done in Proxmox LXC, Ubuntu 20.04, Python 3.8 Prerequisites \u00b6 A Linux or Mac \"Server\". Windows currently does not work. A \"Server\" is a computer that is typically always online. Python 3.7 or later. Plugins may have other requirements as well. Optional Prerequisites \u00b6 If you intend to use Docker, this guide should help you get started. The author of fHDHR is not a docker user, but will still try to help. Installation \u00b6 Linux \u00b6 The below instructions use the user \"sysop\", but you can run it as any user. The script will allow you to run as root, but warns against doing so. Download the release zip, or git clone to your prefered location. cd /home/sysop && git clone https://github.com/fHDHR/fHDHR.git Navigate into your script directory and install the python requirements. cd fHDHR && pip3 install -r requirements.txt Copy the included config.example.ini file to a known location: cp config.example.ini /home/sysop/config.ini The script will not run without this - there is no default configuration file location. Modify the configuration file to suit your needs. Install desired fHDHR plugins. fHDHR will technically run without plugins installed, but is practically useless without an \"origin\" plugin. Install plugin python requirements file: pip3 install -r requirements.txt Run with the path to the config file: python3 /home/sysop/fhdhr/main.py -c = /home/sysop/config.ini Docker \u00b6 If you wish to use fHDHR in Docker, then check out the Docker documentation . Setup \u00b6 Now that you have fHDHR running, you can navigate (in a web browser) to the IP:Port from the configuration step above. If you did not setup a discovery_address in your config, SSDP will be disabled. This is not a problem as clients like Plex can have the IP:Port entered manually! You can copy the xmltv link from the webUI and use that in your client software to provide Channel Guide information.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#author-notes","text":"All Testing is currently done in Proxmox LXC, Ubuntu 20.04, Python 3.8","title":"Author Notes"},{"location":"usage/#prerequisites","text":"A Linux or Mac \"Server\". Windows currently does not work. A \"Server\" is a computer that is typically always online. Python 3.7 or later. Plugins may have other requirements as well.","title":"Prerequisites"},{"location":"usage/#optional-prerequisites","text":"If you intend to use Docker, this guide should help you get started. The author of fHDHR is not a docker user, but will still try to help.","title":"Optional Prerequisites"},{"location":"usage/#installation","text":"","title":"Installation"},{"location":"usage/#linux","text":"The below instructions use the user \"sysop\", but you can run it as any user. The script will allow you to run as root, but warns against doing so. Download the release zip, or git clone to your prefered location. cd /home/sysop && git clone https://github.com/fHDHR/fHDHR.git Navigate into your script directory and install the python requirements. cd fHDHR && pip3 install -r requirements.txt Copy the included config.example.ini file to a known location: cp config.example.ini /home/sysop/config.ini The script will not run without this - there is no default configuration file location. Modify the configuration file to suit your needs. Install desired fHDHR plugins. fHDHR will technically run without plugins installed, but is practically useless without an \"origin\" plugin. Install plugin python requirements file: pip3 install -r requirements.txt Run with the path to the config file: python3 /home/sysop/fhdhr/main.py -c = /home/sysop/config.ini","title":"Linux"},{"location":"usage/#docker","text":"If you wish to use fHDHR in Docker, then check out the Docker documentation .","title":"Docker"},{"location":"usage/#setup","text":"Now that you have fHDHR running, you can navigate (in a web browser) to the IP:Port from the configuration step above. If you did not setup a discovery_address in your config, SSDP will be disabled. This is not a problem as clients like Plex can have the IP:Port entered manually! You can copy the xmltv link from the webUI and use that in your client software to provide Channel Guide information.","title":"Setup"},{"location":"webui/","text":"WebUI \u00b6 This Page will introduce basic handling of the script from the Web Interface provided at IP:Port The Pages are available in the buttons at the top, links to xmltv and m3u are provided at the top for ease of access. Main Landing Page \u00b6 Below is the main landing page with basic information. Channels \u00b6 This Page will display the channels you have per your origin plugin. It will also provide access to a Channel Editor. Note: The Play link in the left hand column can be copied to play a channel in VLC media player! Channel Editor \u00b6 This Page will allow you to edit the channels you have per your origin plugin. From here, you can adjust the channel logo, the channel number, and the channel name. Channel Editor Page Guide \u00b6 This Page give you information about what is currently playing on all stations. It will also show the time remaining for each item. Note: The Play link in the left hand column can be copied to play a channel in VLC media player! (If selected EPG is from Origin) Tuners \u00b6 This Page will show all active tuner information. You can also terminate a stream from here. Note: Clients will often have an amount buffered, and the connection termination is not immediate from a viewing perspective. However, the connection to the source is indeed cut off. xmltv \u00b6 This page will give you access to all the xmltv formats provided by this variant. From here, you can manually update or even clear the cached epg, and then update. Version \u00b6 This page will give valuable information about the environment the script is being run in. Diagnostics \u00b6 This page has various links to json/xml files that make the magic work. Settings \u00b6 This page allows viewing/changing all possible configuration options. Note: This will require a restart of the script to have any effect.","title":"WebUI"},{"location":"webui/#webui","text":"This Page will introduce basic handling of the script from the Web Interface provided at IP:Port The Pages are available in the buttons at the top, links to xmltv and m3u are provided at the top for ease of access.","title":"WebUI"},{"location":"webui/#main-landing-page","text":"Below is the main landing page with basic information.","title":"Main Landing Page"},{"location":"webui/#channels","text":"This Page will display the channels you have per your origin plugin. It will also provide access to a Channel Editor. Note: The Play link in the left hand column can be copied to play a channel in VLC media player!","title":"Channels"},{"location":"webui/#channel-editor","text":"This Page will allow you to edit the channels you have per your origin plugin. From here, you can adjust the channel logo, the channel number, and the channel name. Channel Editor Page","title":"Channel Editor"},{"location":"webui/#guide","text":"This Page give you information about what is currently playing on all stations. It will also show the time remaining for each item. Note: The Play link in the left hand column can be copied to play a channel in VLC media player! (If selected EPG is from Origin)","title":"Guide"},{"location":"webui/#tuners","text":"This Page will show all active tuner information. You can also terminate a stream from here. Note: Clients will often have an amount buffered, and the connection termination is not immediate from a viewing perspective. However, the connection to the source is indeed cut off.","title":"Tuners"},{"location":"webui/#xmltv","text":"This page will give you access to all the xmltv formats provided by this variant. From here, you can manually update or even clear the cached epg, and then update.","title":"xmltv"},{"location":"webui/#version","text":"This page will give valuable information about the environment the script is being run in.","title":"Version"},{"location":"webui/#diagnostics","text":"This page has various links to json/xml files that make the magic work.","title":"Diagnostics"},{"location":"webui/#settings","text":"This page allows viewing/changing all possible configuration options. Note: This will require a restart of the script to have any effect.","title":"Settings"}]}